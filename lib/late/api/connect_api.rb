=begin
#Late API

#API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 

The version of the OpenAPI document: 1.0.1
Contact: support@getlate.dev
Generated by: https://openapi-generator.tech
Generator version: 7.19.0

=end

require 'cgi'

module Late
  class ConnectApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Check Telegram connection status
    # Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - `pending`: Code is valid, waiting for user to complete connection - `connected`: Connection successful - channel/group is now linked - `expired`: Code has expired, generate a new one 
    # @param code [String] The access code to check status for
    # @param [Hash] opts the optional parameters
    # @return [CompleteTelegramConnect200Response]
    def complete_telegram_connect(code, opts = {})
      data, _status_code, _headers = complete_telegram_connect_with_http_info(code, opts)
      data
    end

    # Check Telegram connection status
    # Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
    # @param code [String] The access code to check status for
    # @param [Hash] opts the optional parameters
    # @return [Array<(CompleteTelegramConnect200Response, Integer, Hash)>] CompleteTelegramConnect200Response data, response status code and response headers
    def complete_telegram_connect_with_http_info(code, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.complete_telegram_connect ...'
      end
      # verify the required parameter 'code' is set
      if @api_client.config.client_side_validation && code.nil?
        fail ArgumentError, "Missing the required parameter 'code' when calling ConnectApi.complete_telegram_connect"
      end
      # resource path
      local_var_path = '/v1/connect/telegram'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'code'] = code

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CompleteTelegramConnect200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.complete_telegram_connect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#complete_telegram_connect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Connect Bluesky using app password
    # Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call `GET /v1/users` - the response includes a `currentUserId` field. 
    # @param connect_bluesky_credentials_request [ConnectBlueskyCredentialsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [ConnectBlueskyCredentials200Response]
    def connect_bluesky_credentials(connect_bluesky_credentials_request, opts = {})
      data, _status_code, _headers = connect_bluesky_credentials_with_http_info(connect_bluesky_credentials_request, opts)
      data
    end

    # Connect Bluesky using app password
    # Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
    # @param connect_bluesky_credentials_request [ConnectBlueskyCredentialsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ConnectBlueskyCredentials200Response, Integer, Hash)>] ConnectBlueskyCredentials200Response data, response status code and response headers
    def connect_bluesky_credentials_with_http_info(connect_bluesky_credentials_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.connect_bluesky_credentials ...'
      end
      # verify the required parameter 'connect_bluesky_credentials_request' is set
      if @api_client.config.client_side_validation && connect_bluesky_credentials_request.nil?
        fail ArgumentError, "Missing the required parameter 'connect_bluesky_credentials_request' when calling ConnectApi.connect_bluesky_credentials"
      end
      # resource path
      local_var_path = '/v1/connect/bluesky/credentials'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(connect_bluesky_credentials_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ConnectBlueskyCredentials200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.connect_bluesky_credentials",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#connect_bluesky_credentials\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Start OAuth connection for a platform
    # Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and `redirect_url` (optional) 2. Redirect your user to the returned `authUrl` 3. After OAuth, the user is redirected to Late’s hosted page selector at      `/connect/facebook/select-page?profileId=X&tempToken=Y&userProfile=Z&redirect_url=YOUR_URL&connect_token=CT` 4. After they pick a page, Late saves the connection and finally redirects to your `redirect_url` (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest & Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add `&headless=true`, e.g.      `GET /v1/connect/facebook?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true` 2. Redirect your user to the returned `authUrl` 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:    - `profileId` – your Late profile ID      - `tempToken` – temporary Facebook access token      - `userProfile` – URL‑encoded JSON user profile      - `connect_token` – short‑lived connect token (for API auth)      - `platform=facebook`      - `step=select_page` 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:    - `GET /v1/connect/facebook/select-page` to fetch pages    - `POST /v1/connect/facebook/select-page` to save the selected page 5. In this mode, users never see Late's hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with `&headless=true`, e.g.    `GET /v1/connect/linkedin?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true` 2. Redirect your user to the returned `authUrl` 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:    - `profileId` – your Late profile ID    - `pendingDataToken` – token to fetch OAuth data via API (see step 4)    - `connect_token` – short-lived connect token (for API auth)    - `platform=linkedin`    - `step=select_organization` 4. Call `GET /v1/connect/pending-data?token=PENDING_DATA_TOKEN` to fetch the OAuth data:    - `tempToken` – temporary LinkedIn access token    - `userProfile` – JSON object with `id`, `username`, `displayName`, `profilePicture`    - `organizations` – JSON array with `id`, `urn`, `name`, `vanityName` for each org    - `refreshToken` / `expiresIn` – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call `GET /v1/connect/linkedin/organizations?tempToken=X&orgIds=id1,id2,...` 6. Call `POST /v1/connect/linkedin/select-organization` with the `X-Connect-Token` header to save the selection. 7. In this mode, users never see Late's hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, `step=select_organization` will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with `&headless=true`, e.g.    `GET /v1/connect/pinterest?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true` 2. Redirect your user to the returned `authUrl` 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:    - `profileId` – your Late profile ID    - `tempToken` – temporary Pinterest access token    - `userProfile` – URL‑encoded JSON user profile    - `connect_token` – short‑lived connect token (for API auth)    - `platform=pinterest`    - `step=select_board` 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:    - `GET /v1/connect/pinterest/select-board` to fetch boards    - `POST /v1/connect/pinterest/select-board` to save the selected board 5. In this mode, users never see Late's hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with `&headless=true`, e.g.    `GET /v1/connect/googlebusiness?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true` 2. Redirect your user to the returned `authUrl` 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:    - `profileId` – your Late profile ID    - `tempToken` – temporary Google access token    - `userProfile` – URL‑encoded JSON user profile (includes refresh token info)    - `connect_token` – short‑lived connect token (for API auth)    - `platform=googlebusiness`    - `step=select_location` 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:    - `GET /v1/connect/googlebusiness/locations` to fetch business locations    - `POST /v1/connect/googlebusiness/select-location` to save the selected location 5. In this mode, users never see Late's hosted location selector – only your UI. 
    # @param platform [String] Social media platform to connect
    # @param profile_id [String] Your Late profile ID (get from /v1/profiles)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :redirect_url Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60; 
    # @return [GetConnectUrl200Response]
    def get_connect_url(platform, profile_id, opts = {})
      data, _status_code, _headers = get_connect_url_with_http_info(platform, profile_id, opts)
      data
    end

    # Start OAuth connection for a platform
    # Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
    # @param platform [String] Social media platform to connect
    # @param profile_id [String] Your Late profile ID (get from /v1/profiles)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :redirect_url Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60; 
    # @return [Array<(GetConnectUrl200Response, Integer, Hash)>] GetConnectUrl200Response data, response status code and response headers
    def get_connect_url_with_http_info(platform, profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_connect_url ...'
      end
      # verify the required parameter 'platform' is set
      if @api_client.config.client_side_validation && platform.nil?
        fail ArgumentError, "Missing the required parameter 'platform' when calling ConnectApi.get_connect_url"
      end
      # verify enum value
      allowable_values = ["facebook", "instagram", "linkedin", "twitter", "tiktok", "youtube", "threads", "reddit", "pinterest", "bluesky", "googlebusiness", "telegram", "snapchat"]
      if @api_client.config.client_side_validation && !allowable_values.include?(platform)
        fail ArgumentError, "invalid value for \"platform\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.get_connect_url"
      end
      # resource path
      local_var_path = '/v1/connect/{platform}'.sub('{' + 'platform' + '}', CGI.escape(platform.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id
      query_params[:'redirect_url'] = opts[:'redirect_url'] if !opts[:'redirect_url'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetConnectUrl200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_connect_url",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_connect_url\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List available Facebook pages for a connected account
    # Returns all Facebook pages the connected account has access to, including the currently selected page.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [GetFacebookPages200Response]
    def get_facebook_pages(account_id, opts = {})
      data, _status_code, _headers = get_facebook_pages_with_http_info(account_id, opts)
      data
    end

    # List available Facebook pages for a connected account
    # Returns all Facebook pages the connected account has access to, including the currently selected page.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetFacebookPages200Response, Integer, Hash)>] GetFacebookPages200Response data, response status code and response headers
    def get_facebook_pages_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_facebook_pages ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_facebook_pages"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/facebook-page'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetFacebookPages200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_facebook_pages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_facebook_pages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List available Google Business Profile locations for a connected account
    # Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [GetGmbLocations200Response]
    def get_gmb_locations(account_id, opts = {})
      data, _status_code, _headers = get_gmb_locations_with_http_info(account_id, opts)
      data
    end

    # List available Google Business Profile locations for a connected account
    # Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetGmbLocations200Response, Integer, Hash)>] GetGmbLocations200Response data, response status code and response headers
    def get_gmb_locations_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_gmb_locations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_gmb_locations"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/gmb-locations'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetGmbLocations200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_gmb_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_gmb_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get available LinkedIn organizations for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [GetLinkedInOrganizations200Response]
    def get_linked_in_organizations(account_id, opts = {})
      data, _status_code, _headers = get_linked_in_organizations_with_http_info(account_id, opts)
      data
    end

    # Get available LinkedIn organizations for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetLinkedInOrganizations200Response, Integer, Hash)>] GetLinkedInOrganizations200Response data, response status code and response headers
    def get_linked_in_organizations_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_linked_in_organizations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_linked_in_organizations"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/linkedin-organizations'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetLinkedInOrganizations200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_linked_in_organizations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_linked_in_organizations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fetch pending OAuth selection data (Headless Mode)
    # **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the `pendingDataToken` from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
    # @param token [String] The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)
    # @param [Hash] opts the optional parameters
    # @return [GetPendingOAuthData200Response]
    def get_pending_o_auth_data(token, opts = {})
      data, _status_code, _headers = get_pending_o_auth_data_with_http_info(token, opts)
      data
    end

    # Fetch pending OAuth selection data (Headless Mode)
    # **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
    # @param token [String] The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetPendingOAuthData200Response, Integer, Hash)>] GetPendingOAuthData200Response data, response status code and response headers
    def get_pending_o_auth_data_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_pending_o_auth_data ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling ConnectApi.get_pending_o_auth_data"
      end
      # resource path
      local_var_path = '/v1/connect/pending-data'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetPendingOAuthData200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_pending_o_auth_data",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_pending_o_auth_data\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Pinterest boards for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [GetPinterestBoards200Response]
    def get_pinterest_boards(account_id, opts = {})
      data, _status_code, _headers = get_pinterest_boards_with_http_info(account_id, opts)
      data
    end

    # List Pinterest boards for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetPinterestBoards200Response, Integer, Hash)>] GetPinterestBoards200Response data, response status code and response headers
    def get_pinterest_boards_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_pinterest_boards ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_pinterest_boards"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/pinterest-boards'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetPinterestBoards200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_pinterest_boards",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_pinterest_boards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List available post flairs for a Reddit subreddit
    # @param account_id [String] 
    # @param subreddit [String] Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for
    # @param [Hash] opts the optional parameters
    # @return [GetRedditFlairs200Response]
    def get_reddit_flairs(account_id, subreddit, opts = {})
      data, _status_code, _headers = get_reddit_flairs_with_http_info(account_id, subreddit, opts)
      data
    end

    # List available post flairs for a Reddit subreddit
    # @param account_id [String] 
    # @param subreddit [String] Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetRedditFlairs200Response, Integer, Hash)>] GetRedditFlairs200Response data, response status code and response headers
    def get_reddit_flairs_with_http_info(account_id, subreddit, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_reddit_flairs ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_reddit_flairs"
      end
      # verify the required parameter 'subreddit' is set
      if @api_client.config.client_side_validation && subreddit.nil?
        fail ArgumentError, "Missing the required parameter 'subreddit' when calling ConnectApi.get_reddit_flairs"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/reddit-flairs'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'subreddit'] = subreddit

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetRedditFlairs200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_reddit_flairs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_reddit_flairs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Reddit subreddits for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [GetRedditSubreddits200Response]
    def get_reddit_subreddits(account_id, opts = {})
      data, _status_code, _headers = get_reddit_subreddits_with_http_info(account_id, opts)
      data
    end

    # List Reddit subreddits for a connected account
    # @param account_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetRedditSubreddits200Response, Integer, Hash)>] GetRedditSubreddits200Response data, response status code and response headers
    def get_reddit_subreddits_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_reddit_subreddits ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.get_reddit_subreddits"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/reddit-subreddits'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetRedditSubreddits200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_reddit_subreddits",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_reddit_subreddits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Generate Telegram access code
    # Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: `{CODE} @yourchannel` (e.g., `LATE-ABC123 @mychannel`) 5. Poll `PATCH /v1/connect/telegram?code={CODE}` to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
    # @param profile_id [String] The profile ID to connect the Telegram account to
    # @param [Hash] opts the optional parameters
    # @return [GetTelegramConnectStatus200Response]
    def get_telegram_connect_status(profile_id, opts = {})
      data, _status_code, _headers = get_telegram_connect_status_with_http_info(profile_id, opts)
      data
    end

    # Generate Telegram access code
    # Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
    # @param profile_id [String] The profile ID to connect the Telegram account to
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetTelegramConnectStatus200Response, Integer, Hash)>] GetTelegramConnectStatus200Response data, response status code and response headers
    def get_telegram_connect_status_with_http_info(profile_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.get_telegram_connect_status ...'
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.get_telegram_connect_status"
      end
      # resource path
      local_var_path = '/v1/connect/telegram'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetTelegramConnectStatus200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.get_telegram_connect_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#get_telegram_connect_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Complete OAuth token exchange manually (for server-side flows)
    # @param platform [String] 
    # @param handle_o_auth_callback_request [HandleOAuthCallbackRequest] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def handle_o_auth_callback(platform, handle_o_auth_callback_request, opts = {})
      handle_o_auth_callback_with_http_info(platform, handle_o_auth_callback_request, opts)
      nil
    end

    # Complete OAuth token exchange manually (for server-side flows)
    # @param platform [String] 
    # @param handle_o_auth_callback_request [HandleOAuthCallbackRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def handle_o_auth_callback_with_http_info(platform, handle_o_auth_callback_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.handle_o_auth_callback ...'
      end
      # verify the required parameter 'platform' is set
      if @api_client.config.client_side_validation && platform.nil?
        fail ArgumentError, "Missing the required parameter 'platform' when calling ConnectApi.handle_o_auth_callback"
      end
      # verify the required parameter 'handle_o_auth_callback_request' is set
      if @api_client.config.client_side_validation && handle_o_auth_callback_request.nil?
        fail ArgumentError, "Missing the required parameter 'handle_o_auth_callback_request' when calling ConnectApi.handle_o_auth_callback"
      end
      # resource path
      local_var_path = '/v1/connect/{platform}'.sub('{' + 'platform' + '}', CGI.escape(platform.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(handle_o_auth_callback_request)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.handle_o_auth_callback",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#handle_o_auth_callback\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Direct Telegram connection (power users)
    # Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
    # @param initiate_telegram_connect_request [InitiateTelegramConnectRequest] 
    # @param [Hash] opts the optional parameters
    # @return [InitiateTelegramConnect200Response]
    def initiate_telegram_connect(initiate_telegram_connect_request, opts = {})
      data, _status_code, _headers = initiate_telegram_connect_with_http_info(initiate_telegram_connect_request, opts)
      data
    end

    # Direct Telegram connection (power users)
    # Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
    # @param initiate_telegram_connect_request [InitiateTelegramConnectRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InitiateTelegramConnect200Response, Integer, Hash)>] InitiateTelegramConnect200Response data, response status code and response headers
    def initiate_telegram_connect_with_http_info(initiate_telegram_connect_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.initiate_telegram_connect ...'
      end
      # verify the required parameter 'initiate_telegram_connect_request' is set
      if @api_client.config.client_side_validation && initiate_telegram_connect_request.nil?
        fail ArgumentError, "Missing the required parameter 'initiate_telegram_connect_request' when calling ConnectApi.initiate_telegram_connect"
      end
      # resource path
      local_var_path = '/v1/connect/telegram'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(initiate_telegram_connect_request)

      # return_type
      return_type = opts[:debug_return_type] || 'InitiateTelegramConnect200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.initiate_telegram_connect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#initiate_telegram_connect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Facebook Pages after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Facebook OAuth via `/v1/connect/facebook`, you'll be redirected to  `/connect/facebook/select-page` with query params including `tempToken` and `userProfile`.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key  (rather than a browser session). 
    # @param profile_id [String] Profile ID from your connection flow
    # @param temp_token [String] Temporary Facebook access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [ListFacebookPages200Response]
    def list_facebook_pages(profile_id, temp_token, opts = {})
      data, _status_code, _headers = list_facebook_pages_with_http_info(profile_id, temp_token, opts)
      data
    end

    # List Facebook Pages after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
    # @param profile_id [String] Profile ID from your connection flow
    # @param temp_token [String] Temporary Facebook access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListFacebookPages200Response, Integer, Hash)>] ListFacebookPages200Response data, response status code and response headers
    def list_facebook_pages_with_http_info(profile_id, temp_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.list_facebook_pages ...'
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.list_facebook_pages"
      end
      # verify the required parameter 'temp_token' is set
      if @api_client.config.client_side_validation && temp_token.nil?
        fail ArgumentError, "Missing the required parameter 'temp_token' when calling ConnectApi.list_facebook_pages"
      end
      # resource path
      local_var_path = '/v1/connect/facebook/select-page'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id
      query_params[:'tempToken'] = temp_token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListFacebookPages200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['connectToken', 'bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.list_facebook_pages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#list_facebook_pages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Google Business Locations after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Google Business OAuth via `/v1/connect/googlebusiness?headless=true`, you'll be redirected  to your `redirect_url` with query params including `tempToken` and `userProfile`.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key  (rather than a browser session). 
    # @param profile_id [String] Profile ID from your connection flow
    # @param temp_token [String] Temporary Google access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [ListGoogleBusinessLocations200Response]
    def list_google_business_locations(profile_id, temp_token, opts = {})
      data, _status_code, _headers = list_google_business_locations_with_http_info(profile_id, temp_token, opts)
      data
    end

    # List Google Business Locations after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
    # @param profile_id [String] Profile ID from your connection flow
    # @param temp_token [String] Temporary Google access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListGoogleBusinessLocations200Response, Integer, Hash)>] ListGoogleBusinessLocations200Response data, response status code and response headers
    def list_google_business_locations_with_http_info(profile_id, temp_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.list_google_business_locations ...'
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.list_google_business_locations"
      end
      # verify the required parameter 'temp_token' is set
      if @api_client.config.client_side_validation && temp_token.nil?
        fail ArgumentError, "Missing the required parameter 'temp_token' when calling ConnectApi.list_google_business_locations"
      end
      # resource path
      local_var_path = '/v1/connect/googlebusiness/locations'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id
      query_params[:'tempToken'] = temp_token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListGoogleBusinessLocations200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['connectToken', 'bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.list_google_business_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#list_google_business_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fetch full LinkedIn organization details (Headless Mode)
    # **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only `id`, `urn`, and `name` fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the `tempToken` from the OAuth redirect. Details are fetched directly from LinkedIn's API in parallel for fast response times. 
    # @param temp_token [String] The temporary LinkedIn access token from the OAuth redirect
    # @param org_ids [String] Comma-separated list of organization IDs to fetch details for (max 100)
    # @param [Hash] opts the optional parameters
    # @return [ListLinkedInOrganizations200Response]
    def list_linked_in_organizations(temp_token, org_ids, opts = {})
      data, _status_code, _headers = list_linked_in_organizations_with_http_info(temp_token, org_ids, opts)
      data
    end

    # Fetch full LinkedIn organization details (Headless Mode)
    # **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
    # @param temp_token [String] The temporary LinkedIn access token from the OAuth redirect
    # @param org_ids [String] Comma-separated list of organization IDs to fetch details for (max 100)
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListLinkedInOrganizations200Response, Integer, Hash)>] ListLinkedInOrganizations200Response data, response status code and response headers
    def list_linked_in_organizations_with_http_info(temp_token, org_ids, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.list_linked_in_organizations ...'
      end
      # verify the required parameter 'temp_token' is set
      if @api_client.config.client_side_validation && temp_token.nil?
        fail ArgumentError, "Missing the required parameter 'temp_token' when calling ConnectApi.list_linked_in_organizations"
      end
      # verify the required parameter 'org_ids' is set
      if @api_client.config.client_side_validation && org_ids.nil?
        fail ArgumentError, "Missing the required parameter 'org_ids' when calling ConnectApi.list_linked_in_organizations"
      end
      # resource path
      local_var_path = '/v1/connect/linkedin/organizations'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'tempToken'] = temp_token
      query_params[:'orgIds'] = org_ids

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListLinkedInOrganizations200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.list_linked_in_organizations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#list_linked_in_organizations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Pinterest Boards after OAuth (Headless Mode)
    # **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via `/v1/connect/pinterest` with `headless=true`, you'll be redirected to your `redirect_url` with query params including `tempToken` and `userProfile`.  If you want to build your own fully-branded board selector (instead of Late's hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call `POST /v1/connect/pinterest/select-board` to save the selection.  **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL. 
    # @param x_connect_token [String] Short-lived connect token from the OAuth redirect
    # @param profile_id [String] Your Late profile ID
    # @param temp_token [String] Temporary Pinterest access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [ListPinterestBoardsForSelection200Response]
    def list_pinterest_boards_for_selection(x_connect_token, profile_id, temp_token, opts = {})
      data, _status_code, _headers = list_pinterest_boards_for_selection_with_http_info(x_connect_token, profile_id, temp_token, opts)
      data
    end

    # List Pinterest Boards after OAuth (Headless Mode)
    # **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
    # @param x_connect_token [String] Short-lived connect token from the OAuth redirect
    # @param profile_id [String] Your Late profile ID
    # @param temp_token [String] Temporary Pinterest access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListPinterestBoardsForSelection200Response, Integer, Hash)>] ListPinterestBoardsForSelection200Response data, response status code and response headers
    def list_pinterest_boards_for_selection_with_http_info(x_connect_token, profile_id, temp_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.list_pinterest_boards_for_selection ...'
      end
      # verify the required parameter 'x_connect_token' is set
      if @api_client.config.client_side_validation && x_connect_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_connect_token' when calling ConnectApi.list_pinterest_boards_for_selection"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.list_pinterest_boards_for_selection"
      end
      # verify the required parameter 'temp_token' is set
      if @api_client.config.client_side_validation && temp_token.nil?
        fail ArgumentError, "Missing the required parameter 'temp_token' when calling ConnectApi.list_pinterest_boards_for_selection"
      end
      # resource path
      local_var_path = '/v1/connect/pinterest/select-board'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id
      query_params[:'tempToken'] = temp_token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Connect-Token'] = x_connect_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListPinterestBoardsForSelection200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.list_pinterest_boards_for_selection",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#list_pinterest_boards_for_selection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Snapchat Public Profiles after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to your `redirect_url` with query params including `tempToken`, `userProfile`, and `publicProfiles`.  If you want to build your own fully-branded profile selector (instead of Late's hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call `POST /v1/connect/snapchat/select-profile` to save the selection.  **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL. 
    # @param x_connect_token [String] Short-lived connect token from the OAuth redirect
    # @param profile_id [String] Your Late profile ID
    # @param temp_token [String] Temporary Snapchat access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [ListSnapchatProfiles200Response]
    def list_snapchat_profiles(x_connect_token, profile_id, temp_token, opts = {})
      data, _status_code, _headers = list_snapchat_profiles_with_http_info(x_connect_token, profile_id, temp_token, opts)
      data
    end

    # List Snapchat Public Profiles after OAuth (Headless Mode)
    # **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
    # @param x_connect_token [String] Short-lived connect token from the OAuth redirect
    # @param profile_id [String] Your Late profile ID
    # @param temp_token [String] Temporary Snapchat access token from the OAuth callback redirect
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListSnapchatProfiles200Response, Integer, Hash)>] ListSnapchatProfiles200Response data, response status code and response headers
    def list_snapchat_profiles_with_http_info(x_connect_token, profile_id, temp_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.list_snapchat_profiles ...'
      end
      # verify the required parameter 'x_connect_token' is set
      if @api_client.config.client_side_validation && x_connect_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_connect_token' when calling ConnectApi.list_snapchat_profiles"
      end
      # verify the required parameter 'profile_id' is set
      if @api_client.config.client_side_validation && profile_id.nil?
        fail ArgumentError, "Missing the required parameter 'profile_id' when calling ConnectApi.list_snapchat_profiles"
      end
      # verify the required parameter 'temp_token' is set
      if @api_client.config.client_side_validation && temp_token.nil?
        fail ArgumentError, "Missing the required parameter 'temp_token' when calling ConnectApi.list_snapchat_profiles"
      end
      # resource path
      local_var_path = '/v1/connect/snapchat/select-profile'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'profileId'] = profile_id
      query_params[:'tempToken'] = temp_token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Connect-Token'] = x_connect_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ListSnapchatProfiles200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.list_snapchat_profiles",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#list_snapchat_profiles\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Select a Facebook Page to complete the connection (Headless Mode)
    # **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user's selected page.  The `userProfile` should be the decoded JSON object from the `userProfile` query param  in the OAuth callback redirect URL.  **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key. 
    # @param select_facebook_page_request [SelectFacebookPageRequest] 
    # @param [Hash] opts the optional parameters
    # @return [SelectFacebookPage200Response]
    def select_facebook_page(select_facebook_page_request, opts = {})
      data, _status_code, _headers = select_facebook_page_with_http_info(select_facebook_page_request, opts)
      data
    end

    # Select a Facebook Page to complete the connection (Headless Mode)
    # **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
    # @param select_facebook_page_request [SelectFacebookPageRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SelectFacebookPage200Response, Integer, Hash)>] SelectFacebookPage200Response data, response status code and response headers
    def select_facebook_page_with_http_info(select_facebook_page_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.select_facebook_page ...'
      end
      # verify the required parameter 'select_facebook_page_request' is set
      if @api_client.config.client_side_validation && select_facebook_page_request.nil?
        fail ArgumentError, "Missing the required parameter 'select_facebook_page_request' when calling ConnectApi.select_facebook_page"
      end
      # resource path
      local_var_path = '/v1/connect/facebook/select-page'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(select_facebook_page_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SelectFacebookPage200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['connectToken', 'bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.select_facebook_page",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#select_facebook_page\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Select a Google Business location to complete the connection (Headless Mode)
    # **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET `/v1/connect/googlebusiness/locations`  endpoint, call this endpoint to finalize the connection with the user's selected location.  The `userProfile` should be the decoded JSON object from the `userProfile` query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key. 
    # @param select_google_business_location_request [SelectGoogleBusinessLocationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [SelectGoogleBusinessLocation200Response]
    def select_google_business_location(select_google_business_location_request, opts = {})
      data, _status_code, _headers = select_google_business_location_with_http_info(select_google_business_location_request, opts)
      data
    end

    # Select a Google Business location to complete the connection (Headless Mode)
    # **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
    # @param select_google_business_location_request [SelectGoogleBusinessLocationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SelectGoogleBusinessLocation200Response, Integer, Hash)>] SelectGoogleBusinessLocation200Response data, response status code and response headers
    def select_google_business_location_with_http_info(select_google_business_location_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.select_google_business_location ...'
      end
      # verify the required parameter 'select_google_business_location_request' is set
      if @api_client.config.client_side_validation && select_google_business_location_request.nil?
        fail ArgumentError, "Missing the required parameter 'select_google_business_location_request' when calling ConnectApi.select_google_business_location"
      end
      # resource path
      local_var_path = '/v1/connect/googlebusiness/select-location'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(select_google_business_location_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SelectGoogleBusinessLocation200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['connectToken', 'bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.select_google_business_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#select_google_business_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Select LinkedIn organization or personal account after OAuth
    # **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with `organizations` in the URL params (if they have org admin access). The organizations array contains `id`, `urn`, and `name` fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set `accountType` to `personal` to connect as the user's personal LinkedIn profile, or `organization` to connect as a company page (requires `selectedOrganization` object).  **Personal Profile:** To connect a personal LinkedIn account, set `accountType` to `\"personal\"` and **omit** the `selectedOrganization` field entirely. This is the simplest flow.  **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key. 
    # @param select_linked_in_organization_request [SelectLinkedInOrganizationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [SelectLinkedInOrganization200Response]
    def select_linked_in_organization(select_linked_in_organization_request, opts = {})
      data, _status_code, _headers = select_linked_in_organization_with_http_info(select_linked_in_organization_request, opts)
      data
    end

    # Select LinkedIn organization or personal account after OAuth
    # **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
    # @param select_linked_in_organization_request [SelectLinkedInOrganizationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SelectLinkedInOrganization200Response, Integer, Hash)>] SelectLinkedInOrganization200Response data, response status code and response headers
    def select_linked_in_organization_with_http_info(select_linked_in_organization_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.select_linked_in_organization ...'
      end
      # verify the required parameter 'select_linked_in_organization_request' is set
      if @api_client.config.client_side_validation && select_linked_in_organization_request.nil?
        fail ArgumentError, "Missing the required parameter 'select_linked_in_organization_request' when calling ConnectApi.select_linked_in_organization"
      end
      # resource path
      local_var_path = '/v1/connect/linkedin/select-organization'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(select_linked_in_organization_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SelectLinkedInOrganization200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.select_linked_in_organization",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#select_linked_in_organization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Select a Pinterest Board to complete the connection (Headless Mode)
    # **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key. 
    # @param select_pinterest_board_request [SelectPinterestBoardRequest] 
    # @param [Hash] opts the optional parameters
    # @return [SelectPinterestBoard200Response]
    def select_pinterest_board(select_pinterest_board_request, opts = {})
      data, _status_code, _headers = select_pinterest_board_with_http_info(select_pinterest_board_request, opts)
      data
    end

    # Select a Pinterest Board to complete the connection (Headless Mode)
    # **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
    # @param select_pinterest_board_request [SelectPinterestBoardRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SelectPinterestBoard200Response, Integer, Hash)>] SelectPinterestBoard200Response data, response status code and response headers
    def select_pinterest_board_with_http_info(select_pinterest_board_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.select_pinterest_board ...'
      end
      # verify the required parameter 'select_pinterest_board_request' is set
      if @api_client.config.client_side_validation && select_pinterest_board_request.nil?
        fail ArgumentError, "Missing the required parameter 'select_pinterest_board_request' when calling ConnectApi.select_pinterest_board"
      end
      # resource path
      local_var_path = '/v1/connect/pinterest/select-board'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(select_pinterest_board_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SelectPinterestBoard200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.select_pinterest_board",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#select_pinterest_board\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Select a Snapchat Public Profile to complete the connection (Headless Mode)
    # **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.  After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to your `redirect_url` with query params including: - `tempToken` - Temporary access token - `userProfile` - URL-encoded JSON with user info - `publicProfiles` - URL-encoded JSON array of available public profiles - `connect_token` - Short-lived token for API authentication - `platform=snapchat` - `step=select_public_profile`  Parse `publicProfiles` to build your custom selector UI, then call this endpoint with the selected profile. 
    # @param select_snapchat_profile_request [SelectSnapchatProfileRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_connect_token Short-lived connect token from the OAuth redirect (for API users)
    # @return [SelectSnapchatProfile200Response]
    def select_snapchat_profile(select_snapchat_profile_request, opts = {})
      data, _status_code, _headers = select_snapchat_profile_with_http_info(select_snapchat_profile_request, opts)
      data
    end

    # Select a Snapchat Public Profile to complete the connection (Headless Mode)
    # **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
    # @param select_snapchat_profile_request [SelectSnapchatProfileRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :x_connect_token Short-lived connect token from the OAuth redirect (for API users)
    # @return [Array<(SelectSnapchatProfile200Response, Integer, Hash)>] SelectSnapchatProfile200Response data, response status code and response headers
    def select_snapchat_profile_with_http_info(select_snapchat_profile_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.select_snapchat_profile ...'
      end
      # verify the required parameter 'select_snapchat_profile_request' is set
      if @api_client.config.client_side_validation && select_snapchat_profile_request.nil?
        fail ArgumentError, "Missing the required parameter 'select_snapchat_profile_request' when calling ConnectApi.select_snapchat_profile"
      end
      # resource path
      local_var_path = '/v1/connect/snapchat/select-profile'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Connect-Token'] = opts[:'x_connect_token'] if !opts[:'x_connect_token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(select_snapchat_profile_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SelectSnapchatProfile200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.select_snapchat_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#select_snapchat_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update selected Facebook page for a connected account
    # @param account_id [String] 
    # @param update_facebook_page_request [UpdateFacebookPageRequest] 
    # @param [Hash] opts the optional parameters
    # @return [UpdateFacebookPage200Response]
    def update_facebook_page(account_id, update_facebook_page_request, opts = {})
      data, _status_code, _headers = update_facebook_page_with_http_info(account_id, update_facebook_page_request, opts)
      data
    end

    # Update selected Facebook page for a connected account
    # @param account_id [String] 
    # @param update_facebook_page_request [UpdateFacebookPageRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdateFacebookPage200Response, Integer, Hash)>] UpdateFacebookPage200Response data, response status code and response headers
    def update_facebook_page_with_http_info(account_id, update_facebook_page_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.update_facebook_page ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.update_facebook_page"
      end
      # verify the required parameter 'update_facebook_page_request' is set
      if @api_client.config.client_side_validation && update_facebook_page_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_facebook_page_request' when calling ConnectApi.update_facebook_page"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/facebook-page'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_facebook_page_request)

      # return_type
      return_type = opts[:debug_return_type] || 'UpdateFacebookPage200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.update_facebook_page",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#update_facebook_page\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update selected Google Business Profile location for a connected account
    # @param account_id [String] 
    # @param update_gmb_location_request [UpdateGmbLocationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [UpdateGmbLocation200Response]
    def update_gmb_location(account_id, update_gmb_location_request, opts = {})
      data, _status_code, _headers = update_gmb_location_with_http_info(account_id, update_gmb_location_request, opts)
      data
    end

    # Update selected Google Business Profile location for a connected account
    # @param account_id [String] 
    # @param update_gmb_location_request [UpdateGmbLocationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdateGmbLocation200Response, Integer, Hash)>] UpdateGmbLocation200Response data, response status code and response headers
    def update_gmb_location_with_http_info(account_id, update_gmb_location_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.update_gmb_location ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.update_gmb_location"
      end
      # verify the required parameter 'update_gmb_location_request' is set
      if @api_client.config.client_side_validation && update_gmb_location_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_gmb_location_request' when calling ConnectApi.update_gmb_location"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/gmb-locations'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_gmb_location_request)

      # return_type
      return_type = opts[:debug_return_type] || 'UpdateGmbLocation200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.update_gmb_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#update_gmb_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Switch LinkedIn account type (personal/organization)
    # @param account_id [String] 
    # @param update_linked_in_organization_request [UpdateLinkedInOrganizationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [ConnectBlueskyCredentials200Response]
    def update_linked_in_organization(account_id, update_linked_in_organization_request, opts = {})
      data, _status_code, _headers = update_linked_in_organization_with_http_info(account_id, update_linked_in_organization_request, opts)
      data
    end

    # Switch LinkedIn account type (personal/organization)
    # @param account_id [String] 
    # @param update_linked_in_organization_request [UpdateLinkedInOrganizationRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ConnectBlueskyCredentials200Response, Integer, Hash)>] ConnectBlueskyCredentials200Response data, response status code and response headers
    def update_linked_in_organization_with_http_info(account_id, update_linked_in_organization_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.update_linked_in_organization ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.update_linked_in_organization"
      end
      # verify the required parameter 'update_linked_in_organization_request' is set
      if @api_client.config.client_side_validation && update_linked_in_organization_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_linked_in_organization_request' when calling ConnectApi.update_linked_in_organization"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/linkedin-organization'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_linked_in_organization_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ConnectBlueskyCredentials200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.update_linked_in_organization",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#update_linked_in_organization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set default Pinterest board on the connection
    # @param account_id [String] 
    # @param update_pinterest_boards_request [UpdatePinterestBoardsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [ConnectBlueskyCredentials200Response]
    def update_pinterest_boards(account_id, update_pinterest_boards_request, opts = {})
      data, _status_code, _headers = update_pinterest_boards_with_http_info(account_id, update_pinterest_boards_request, opts)
      data
    end

    # Set default Pinterest board on the connection
    # @param account_id [String] 
    # @param update_pinterest_boards_request [UpdatePinterestBoardsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ConnectBlueskyCredentials200Response, Integer, Hash)>] ConnectBlueskyCredentials200Response data, response status code and response headers
    def update_pinterest_boards_with_http_info(account_id, update_pinterest_boards_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.update_pinterest_boards ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.update_pinterest_boards"
      end
      # verify the required parameter 'update_pinterest_boards_request' is set
      if @api_client.config.client_side_validation && update_pinterest_boards_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_pinterest_boards_request' when calling ConnectApi.update_pinterest_boards"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/pinterest-boards'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_pinterest_boards_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ConnectBlueskyCredentials200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.update_pinterest_boards",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#update_pinterest_boards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set default subreddit on the connection
    # @param account_id [String] 
    # @param update_reddit_subreddits_request [UpdateRedditSubredditsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [UpdateRedditSubreddits200Response]
    def update_reddit_subreddits(account_id, update_reddit_subreddits_request, opts = {})
      data, _status_code, _headers = update_reddit_subreddits_with_http_info(account_id, update_reddit_subreddits_request, opts)
      data
    end

    # Set default subreddit on the connection
    # @param account_id [String] 
    # @param update_reddit_subreddits_request [UpdateRedditSubredditsRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdateRedditSubreddits200Response, Integer, Hash)>] UpdateRedditSubreddits200Response data, response status code and response headers
    def update_reddit_subreddits_with_http_info(account_id, update_reddit_subreddits_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConnectApi.update_reddit_subreddits ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ConnectApi.update_reddit_subreddits"
      end
      # verify the required parameter 'update_reddit_subreddits_request' is set
      if @api_client.config.client_side_validation && update_reddit_subreddits_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_reddit_subreddits_request' when calling ConnectApi.update_reddit_subreddits"
      end
      # resource path
      local_var_path = '/v1/accounts/{accountId}/reddit-subreddits'.sub('{' + 'accountId' + '}', CGI.escape(account_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_reddit_subreddits_request)

      # return_type
      return_type = opts[:debug_return_type] || 'UpdateRedditSubreddits200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"ConnectApi.update_reddit_subreddits",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConnectApi#update_reddit_subreddits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
