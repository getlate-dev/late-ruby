=begin
#Late API

#API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 

The version of the OpenAPI document: 1.0.1
Contact: support@getlate.dev
Generated by: https://openapi-generator.tech
Generator version: 7.19.0

=end

require 'cgi'

module Late
  class PostsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Bulk upload from CSV
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :dry_run  (default to false)
    # @option opts [File] :file 
    # @return [BulkUploadPosts200Response]
    def bulk_upload_posts(opts = {})
      data, _status_code, _headers = bulk_upload_posts_with_http_info(opts)
      data
    end

    # Bulk upload from CSV
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :dry_run  (default to false)
    # @option opts [File] :file 
    # @return [Array<(BulkUploadPosts200Response, Integer, Hash)>] BulkUploadPosts200Response data, response status code and response headers
    def bulk_upload_posts_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.bulk_upload_posts ...'
      end
      # resource path
      local_var_path = '/v1/posts/bulk-upload'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'dryRun'] = opts[:'dry_run'] if !opts[:'dry_run'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['multipart/form-data'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['file'] = opts[:'file'] if !opts[:'file'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BulkUploadPosts200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.bulk_upload_posts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#bulk_upload_posts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create post
    # **Getting Post URLs:** - Immediate posts (`publishNow: true`): response includes `platformPostUrl` in `post.platforms[]`. - Scheduled posts: fetch via `GET /v1/posts/{postId}` after publish time for `platformPostUrl`.  **Content requirements:** - `content` is optional when media is attached, all platforms have `customContent`, or posting to YouTube only. - Text-only posts require `content`. Stories ignore captions.  **Platform constraints:** - YouTube: video required, optional thumbnail via `MediaItem.thumbnail` - Instagram/TikTok: media required; TikTok cannot mix videos and images - Instagram carousels: up to 10 items; Threads carousels: up to 10 images only - Facebook Stories: single image or video, set `contentType: 'story'` - LinkedIn: up to 20 images or a single PDF (max 100MB) - Pinterest: single image or video, `boardId` required - Bluesky: up to 4 images, auto-recompressed to ~1MB - Snapchat: single image or video, set `contentType` in platformSpecificData 
    # @param create_post_request [CreatePostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [PostCreateResponse]
    def create_post(create_post_request, opts = {})
      data, _status_code, _headers = create_post_with_http_info(create_post_request, opts)
      data
    end

    # Create post
    # **Getting Post URLs:** - Immediate posts (&#x60;publishNow: true&#x60;): response includes &#x60;platformPostUrl&#x60; in &#x60;post.platforms[]&#x60;. - Scheduled posts: fetch via &#x60;GET /v1/posts/{postId}&#x60; after publish time for &#x60;platformPostUrl&#x60;.  **Content requirements:** - &#x60;content&#x60; is optional when media is attached, all platforms have &#x60;customContent&#x60;, or posting to YouTube only. - Text-only posts require &#x60;content&#x60;. Stories ignore captions.  **Platform constraints:** - YouTube: video required, optional thumbnail via &#x60;MediaItem.thumbnail&#x60; - Instagram/TikTok: media required; TikTok cannot mix videos and images - Instagram carousels: up to 10 items; Threads carousels: up to 10 images only - Facebook Stories: single image or video, set &#x60;contentType: &#39;story&#39;&#x60; - LinkedIn: up to 20 images or a single PDF (max 100MB) - Pinterest: single image or video, &#x60;boardId&#x60; required - Bluesky: up to 4 images, auto-recompressed to ~1MB - Snapchat: single image or video, set &#x60;contentType&#x60; in platformSpecificData 
    # @param create_post_request [CreatePostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PostCreateResponse, Integer, Hash)>] PostCreateResponse data, response status code and response headers
    def create_post_with_http_info(create_post_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.create_post ...'
      end
      # verify the required parameter 'create_post_request' is set
      if @api_client.config.client_side_validation && create_post_request.nil?
        fail ArgumentError, "Missing the required parameter 'create_post_request' when calling PostsApi.create_post"
      end
      # resource path
      local_var_path = '/v1/posts'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_post_request)

      # return_type
      return_type = opts[:debug_return_type] || 'PostCreateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.create_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#create_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete post
    # Delete a draft or scheduled post from Late. Only posts that have not been published can be deleted. To remove a published post from a social media platform, use the [Unpublish endpoint](#tag/Posts/operation/unpublishPost) instead. When deleting a scheduled or draft post that consumed upload quota, the quota will be automatically refunded. 
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [PostDeleteResponse]
    def delete_post(post_id, opts = {})
      data, _status_code, _headers = delete_post_with_http_info(post_id, opts)
      data
    end

    # Delete post
    # Delete a draft or scheduled post from Late. Only posts that have not been published can be deleted. To remove a published post from a social media platform, use the [Unpublish endpoint](#tag/Posts/operation/unpublishPost) instead. When deleting a scheduled or draft post that consumed upload quota, the quota will be automatically refunded. 
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PostDeleteResponse, Integer, Hash)>] PostDeleteResponse data, response status code and response headers
    def delete_post_with_http_info(post_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.delete_post ...'
      end
      # verify the required parameter 'post_id' is set
      if @api_client.config.client_side_validation && post_id.nil?
        fail ArgumentError, "Missing the required parameter 'post_id' when calling PostsApi.delete_post"
      end
      # resource path
      local_var_path = '/v1/posts/{postId}'.sub('{' + 'postId' + '}', CGI.escape(post_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PostDeleteResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.delete_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#delete_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get post
    # Fetch a single post by ID. For published posts, this returns `platformPostUrl`  for each platform - useful for retrieving post URLs after scheduled posts publish. 
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [PostGetResponse]
    def get_post(post_id, opts = {})
      data, _status_code, _headers = get_post_with_http_info(post_id, opts)
      data
    end

    # Get post
    # Fetch a single post by ID. For published posts, this returns &#x60;platformPostUrl&#x60;  for each platform - useful for retrieving post URLs after scheduled posts publish. 
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PostGetResponse, Integer, Hash)>] PostGetResponse data, response status code and response headers
    def get_post_with_http_info(post_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.get_post ...'
      end
      # verify the required parameter 'post_id' is set
      if @api_client.config.client_side_validation && post_id.nil?
        fail ArgumentError, "Missing the required parameter 'post_id' when calling PostsApi.get_post"
      end
      # resource path
      local_var_path = '/v1/posts/{postId}'.sub('{' + 'postId' + '}', CGI.escape(post_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PostGetResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.get_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#get_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List posts
    # **Getting Post URLs:** For published posts, each platform entry includes `platformPostUrl` with the public URL. Use `status=published` filter to fetch only published posts with their URLs.  Notes and constraints by platform when interpreting the response: - YouTube: posts always include at least one video in mediaItems. - Instagram/TikTok: posts always include media; drafts may omit media until finalized in client. - TikTok: mediaItems will not mix photos and videos in the same post. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Page number (1-based) (default to 1)
    # @option opts [Integer] :limit Page size (default to 10)
    # @option opts [String] :status 
    # @option opts [String] :platform 
    # @option opts [String] :profile_id 
    # @option opts [String] :created_by 
    # @option opts [Date] :date_from 
    # @option opts [Date] :date_to 
    # @option opts [Boolean] :include_hidden  (default to false)
    # @return [PostsListResponse]
    def list_posts(opts = {})
      data, _status_code, _headers = list_posts_with_http_info(opts)
      data
    end

    # List posts
    # **Getting Post URLs:** For published posts, each platform entry includes &#x60;platformPostUrl&#x60; with the public URL. Use &#x60;status&#x3D;published&#x60; filter to fetch only published posts with their URLs.  Notes and constraints by platform when interpreting the response: - YouTube: posts always include at least one video in mediaItems. - Instagram/TikTok: posts always include media; drafts may omit media until finalized in client. - TikTok: mediaItems will not mix photos and videos in the same post. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Page number (1-based) (default to 1)
    # @option opts [Integer] :limit Page size (default to 10)
    # @option opts [String] :status 
    # @option opts [String] :platform 
    # @option opts [String] :profile_id 
    # @option opts [String] :created_by 
    # @option opts [Date] :date_from 
    # @option opts [Date] :date_to 
    # @option opts [Boolean] :include_hidden  (default to false)
    # @return [Array<(PostsListResponse, Integer, Hash)>] PostsListResponse data, response status code and response headers
    def list_posts_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.list_posts ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling PostsApi.list_posts, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 100
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling PostsApi.list_posts, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling PostsApi.list_posts, must be greater than or equal to 1.'
      end

      allowable_values = ["draft", "scheduled", "published", "failed"]
      if @api_client.config.client_side_validation && opts[:'status'] && !allowable_values.include?(opts[:'status'])
        fail ArgumentError, "invalid value for \"status\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/v1/posts'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'platform'] = opts[:'platform'] if !opts[:'platform'].nil?
      query_params[:'profileId'] = opts[:'profile_id'] if !opts[:'profile_id'].nil?
      query_params[:'createdBy'] = opts[:'created_by'] if !opts[:'created_by'].nil?
      query_params[:'dateFrom'] = opts[:'date_from'] if !opts[:'date_from'].nil?
      query_params[:'dateTo'] = opts[:'date_to'] if !opts[:'date_to'].nil?
      query_params[:'includeHidden'] = opts[:'include_hidden'] if !opts[:'include_hidden'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PostsListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.list_posts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#list_posts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retry failed post
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [PostRetryResponse]
    def retry_post(post_id, opts = {})
      data, _status_code, _headers = retry_post_with_http_info(post_id, opts)
      data
    end

    # Retry failed post
    # @param post_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PostRetryResponse, Integer, Hash)>] PostRetryResponse data, response status code and response headers
    def retry_post_with_http_info(post_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.retry_post ...'
      end
      # verify the required parameter 'post_id' is set
      if @api_client.config.client_side_validation && post_id.nil?
        fail ArgumentError, "Missing the required parameter 'post_id' when calling PostsApi.retry_post"
      end
      # resource path
      local_var_path = '/v1/posts/{postId}/retry'.sub('{' + 'postId' + '}', CGI.escape(post_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PostRetryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.retry_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#retry_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unpublish post
    # Permanently deletes a published post from the specified social media platform. The post record in Late is kept but its platform status is updated to \"cancelled\". This does not delete the post from Late, only from the platform.  **Supported platforms:** Threads, Facebook, Twitter/X, LinkedIn, YouTube, Pinterest, Reddit, Bluesky, Google Business, Telegram.  **Not supported:** - **Instagram:** No deletion API available. Posts must be deleted manually. - **TikTok:** No deletion API available. Posts must be deleted manually. - **Snapchat:** No deletion API available. Posts must be deleted manually.  **Platform notes:** - **Threaded posts (Twitter, Threads, Bluesky):** If the post was published as a thread, all items in the thread are deleted (not just the first one). Posts published before this feature was added will only have the first item deleted. - **Telegram:** Messages older than 48 hours may fail to delete (Telegram Bot API limitation). - **YouTube:** This permanently deletes the video from YouTube. 
    # @param post_id [String] 
    # @param unpublish_post_request [UnpublishPostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [UnpublishPost200Response]
    def unpublish_post(post_id, unpublish_post_request, opts = {})
      data, _status_code, _headers = unpublish_post_with_http_info(post_id, unpublish_post_request, opts)
      data
    end

    # Unpublish post
    # Permanently deletes a published post from the specified social media platform. The post record in Late is kept but its platform status is updated to \&quot;cancelled\&quot;. This does not delete the post from Late, only from the platform.  **Supported platforms:** Threads, Facebook, Twitter/X, LinkedIn, YouTube, Pinterest, Reddit, Bluesky, Google Business, Telegram.  **Not supported:** - **Instagram:** No deletion API available. Posts must be deleted manually. - **TikTok:** No deletion API available. Posts must be deleted manually. - **Snapchat:** No deletion API available. Posts must be deleted manually.  **Platform notes:** - **Threaded posts (Twitter, Threads, Bluesky):** If the post was published as a thread, all items in the thread are deleted (not just the first one). Posts published before this feature was added will only have the first item deleted. - **Telegram:** Messages older than 48 hours may fail to delete (Telegram Bot API limitation). - **YouTube:** This permanently deletes the video from YouTube. 
    # @param post_id [String] 
    # @param unpublish_post_request [UnpublishPostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UnpublishPost200Response, Integer, Hash)>] UnpublishPost200Response data, response status code and response headers
    def unpublish_post_with_http_info(post_id, unpublish_post_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.unpublish_post ...'
      end
      # verify the required parameter 'post_id' is set
      if @api_client.config.client_side_validation && post_id.nil?
        fail ArgumentError, "Missing the required parameter 'post_id' when calling PostsApi.unpublish_post"
      end
      # verify the required parameter 'unpublish_post_request' is set
      if @api_client.config.client_side_validation && unpublish_post_request.nil?
        fail ArgumentError, "Missing the required parameter 'unpublish_post_request' when calling PostsApi.unpublish_post"
      end
      # resource path
      local_var_path = '/v1/posts/{postId}/unpublish'.sub('{' + 'postId' + '}', CGI.escape(post_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(unpublish_post_request)

      # return_type
      return_type = opts[:debug_return_type] || 'UnpublishPost200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.unpublish_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#unpublish_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update post
    # Update an existing post. Only draft, scheduled, failed, and partial posts can be edited. Published, publishing, and cancelled posts cannot be modified. 
    # @param post_id [String] 
    # @param update_post_request [UpdatePostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [PostUpdateResponse]
    def update_post(post_id, update_post_request, opts = {})
      data, _status_code, _headers = update_post_with_http_info(post_id, update_post_request, opts)
      data
    end

    # Update post
    # Update an existing post. Only draft, scheduled, failed, and partial posts can be edited. Published, publishing, and cancelled posts cannot be modified. 
    # @param post_id [String] 
    # @param update_post_request [UpdatePostRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PostUpdateResponse, Integer, Hash)>] PostUpdateResponse data, response status code and response headers
    def update_post_with_http_info(post_id, update_post_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: PostsApi.update_post ...'
      end
      # verify the required parameter 'post_id' is set
      if @api_client.config.client_side_validation && post_id.nil?
        fail ArgumentError, "Missing the required parameter 'post_id' when calling PostsApi.update_post"
      end
      # verify the required parameter 'update_post_request' is set
      if @api_client.config.client_side_validation && update_post_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_post_request' when calling PostsApi.update_post"
      end
      # resource path
      local_var_path = '/v1/posts/{postId}'.sub('{' + 'postId' + '}', CGI.escape(post_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_post_request)

      # return_type
      return_type = opts[:debug_return_type] || 'PostUpdateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"PostsApi.update_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: PostsApi#update_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
